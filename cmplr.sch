(define (cmplr emit env exp)
  (define (recur exp) (cmplr emit env exp))
  (define (recur-enter frame exp) (cmplr emit (cons frame env) exp))
  (define (do-binop op exps)
    (recur (car exps))
    (for ((exp (in-list (cdr exps))))
      (recur exp)
      (emit op)))
  (define (do-addmul op unit exps)
    (if (null? exps) (emit 'ldc unit)
	(do-binop 'add exps)))
  (define (do-sub exps)
    (cond
     ((null? exps) (error "- needs arguments"))
     ((null? (cdr exps)) (do-sub (cons 0 exps)))
     (else (do-binop 'sub exps))))
  (define (do-div exps)
    (cond
     ((null? exps) (error "/ needs arguments"))
     ((null? (cdr exps)) (error "/ needs more arguments"))
     (else (do-binop 'div exps))))

  (cond
   ((integer? exp) (emit 'ldc exp))
   ((symbol? exp)
    (let floop ((env env) (n 0))
      (when (null? env) 
	    (error "unbound variable:" exp))
      (let vloop ((frame (car env)) (i 0))
	(cond
	 ((null? frame) (floop (cdr env) (+ n 1)))
	 ((eq? (car frame) exp) (emit 'ld n i))
	 (else (vloop (cdr frame) (+ i 1)))))))
   ((cons? exp)
    (case (car exp)
      ((+) (do-addmul 'add 0 (cdr exp)))
      ((-) (do-sub (cdr exp)))
      ((*) (do-addmul 'mul 1 (cdr exp)))
      ((/) (do-div (cdr exp)))
      ((= < > <= >= cons)
       (unless (= (length exp) 3)
	 (error "wrong arity for binary operator:" exp))
       (let ((lhs (cadr exp))
	     (rhs (caddr exp)))
	 (case (car exp)
	   ((=) (recur lhs) (recur rhs) (emit 'ceq))
	   ((>) (recur lhs) (recur rhs) (emit 'cgt))
	   ((<) (recur rhs) (recur lhs) (emit 'cgt))
	   ((>=) (recur lhs) (recur rhs) (emit 'cgte))
	   ((<=) (recur rhs) (recur lhs) (emit 'cgte))
	   ((cons) (recur lhs) (recur rhs) (emit 'cons)))))
      ((atom car cdr)
       (unless (= (length exp) 2)
	 (error "wrong arity for unary operator:" exp)
	 (recur (cadr exp))
	 (emit (car exp))))
      ;; TODO
      (else (error "unknown operator:" exp))))
   (else (error "unhandled expression:" exp))))
