(struct block (insns children base) #:mutable)
(define (new-block) (block '() '() #f))
(define (block-emit block op . args)
  (set-block-insns! block (cons (cons op args) (block-insns block))))
(define (block-fork parent)
  (let ((child (new-block)))
    (set-block-children! parent (cons child (block-children parent)))
    child))
(define (block-descendents main)
  (let ((acc '()))
    (let loop ((block main))
      (set! acc (cons block acc))
      (for-each loop (block-children block)))
    (reverse acc)))

(define (block-layout! main)
  (for/fold ((here 0)) ((block (in-list (block-descendents main))))
    (set-block-base! block here)
    (+ here (length (block-insns block)))))

(define (insn-fmt op args)
  (apply string-append (string-upcase (symbol->string op))
	 (map (lambda (arg) (format " ~a" arg)) args)))
(define (arg-expand arg)
  (if (block? arg) (block-base arg) arg))

(define (block->strings main (with-labels #f))
  (block-layout! main)
  (reverse
   (for/fold ((lines '()))
       ((block (in-list (block-descendents main)))
	#:when #t
	(insn (in-list (reverse (block-insns block))))
	(i (in-naturals (block-base block))))
     (let ((op (car insn))
	   (args (cdr insn))
	   (prefix (if with-labels (format "~a: " i) "")))
       (cons (string-append prefix (insn-fmt op (map arg-expand args)) "\n") lines)))))

(define (cmplr/prog exp (with-labels #f))
  (let ((main (new-block)))
    (cmplr main '((initial-world undocumented)) exp 'rtn)
    (for-each display (block->strings main with-labels))))

(define (cmplr/xclip exp)
  (let ((xclip (cadr (process "xclip -i"))))
    (parameterize ((current-output-port xclip)) (cmplr/prog exp))
    (close-output-port xclip)))

(define (cmplr block env exp tail)
  (define (emit . args) (apply block-emit block args))
  (define (recur exp) (cmplr block env exp #f))
  (define (used-tail) (set! tail #f))

  (define (do-binop op exps)
    (recur (car exps))
    (for ((exp (in-list (cdr exps))))
      (recur exp)
      (emit op)))
  (define (do-addmul op unit exps)
    (if (null? exps) (emit 'ldc unit)
	(do-binop op exps)))
  (define (do-sub exps)
    (cond
     ((null? exps) (error "- needs arguments"))
     ((null? (cdr exps)) (do-sub (cons 0 exps)))
     (else (do-binop 'sub exps))))
  (define (do-div exps)
    (cond
     ((null? exps) (error "/ needs arguments"))
     ((null? (cdr exps)) (error "/ needs more arguments"))
     (else (do-binop 'div exps))))

  (cond
   ((integer? exp) (emit 'ldc exp))
   ((symbol? exp)
    (let floop ((env env) (n 0))
      (when (null? env)
	(error "unbound variable:" exp))
      (let vloop ((frame (car env)) (i 0))
	(cond
	 ((null? frame) (floop (cdr env) (+ n 1)))
	 ((eq? (car frame) exp) (emit 'ld n i))
	 (else (vloop (cdr frame) (+ i 1)))))))
   ((cons? exp)
    (case (car exp)
      ((+) (do-addmul 'add 0 (cdr exp)))
      ((-) (do-sub (cdr exp)))
      ((*) (do-addmul 'mul 1 (cdr exp)))
      ((/) (do-div (cdr exp)))
      ((= < > <= >= cons)
       (unless (= (length exp) 3)
	 (error "wrong arity for binary operator:" exp))
       (let ((lhs (cadr exp))
	     (rhs (caddr exp)))
	 (case (car exp)
	   ((=) (recur lhs) (recur rhs) (emit 'ceq))
	   ((>) (recur lhs) (recur rhs) (emit 'cgt))
	   ((<) (recur rhs) (recur lhs) (emit 'cgt))
	   ((>=) (recur lhs) (recur rhs) (emit 'cgte))
	   ((<=) (recur rhs) (recur lhs) (emit 'cgte))
	   ((cons) (recur lhs) (recur rhs) (emit 'cons)))))
      ((atom car cdr)
       (unless (= (length exp) 2)
	 (error "wrong arity for unary operator:" exp))
       (recur (cadr exp))
       (emit (car exp)))
      ((if)
       (unless (= (length exp) 4)
	 (error "wrong arity for conditional:" exp))
       (let ((>then (block-fork block))
	     (>else (block-fork block)))
	 (recur (cadr exp))
	 (if (symbol? tail)
	     (begin
	       (emit 'tsel >then >else)
	       (cmplr >then env (caddr exp) tail)
	       (cmplr >else env (cadddr exp) tail)
	       (used-tail))
	     (begin
	       (emit 'sel >then >else)
	       (cmplr >then env (caddr exp) 'join)
	       (cmplr >else env (cadddr exp) 'join)))))
      ((lambda)
       (unless (and (list? (cadr exp)) (andmap symbol? (cadr exp)))
	 (error "unsupported argument list:" exp))
       (unless (= (length exp) 3)
	 (error "no begin (yet):" exp))
       (let ((>body (block-fork block)))
	 (emit 'ldf >body)
	 (cmplr >body (cons (cadr exp) env) (caddr exp) 'rtn)))
      ((letrec)
       (unless (and (= (length exp) 3) (andmap (lambda (b) (= (length b) 2)) (cadr exp)))
	 (error "no begin (yet):" exp))
       (let ((vars (map car (cadr exp)))
	     (inits (map cadr (cadr exp)))
	     (body (caddr exp)))
	 (emit 'dum (length vars))
	 (for-each (lambda (init) (cmplr block (cons vars env) init #f)) inits)
	 (recur `(lambda ,vars ,body))
	 (if (eq? tail 'rtn)
	     (begin
	       (emit 'trap (length vars))
	       (used-tail))
	     (emit 'rap (length vars)))))

      ;; fake macros
      ((let)
       (unless (and (= (length exp) 3) (andmap (lambda (b) (= (length b) 2)) (cadr exp)))
	 (error "no begin (yet):" exp))
       (let ((vars (map car (cadr exp)))
	     (inits (map cadr (cadr exp)))
	     (body (caddr exp)))
	 (recur `(funcall (lambda ,vars ,body) ,@inits))))
      ((let*)
       (if (null? (cadr exp)) (recur (caddr exp))
	   (recur `(let (,(caadr exp)) (let* ,(cdadr exp) ,@(cddr exp))))))

      ((with-debug)
       (recur (cadr exp))
       (emit 'dbug)
       (recur (caddr exp)))

      ((funcall)
       (for-each recur (cddr exp))
       (recur (cadr exp))
       (if (eq? tail 'rtn)
	   (begin
	     (emit 'tap (length (cddr exp)))
	     (used-tail))
	   (emit 'ap (length (cddr exp)))))
      (else (error "unhandled operator:" exp))))
   (else (error "unhandled expression:" exp)))
  (when (symbol? tail)
    (emit tail)))
