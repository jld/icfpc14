(define (cmplr emit env exp)
  (define (recur exp) (cmplr emit env exp))

  (define (do-binop op exps)
    (recur (car exps))
    (for ((exp (in-list (cdr exps))))
      (recur exp)
      (emit op)))
  (define (do-addmul op unit exps)
    (if (null? exps) (emit 'ldc unit)
	(do-binop 'add exps)))
  (define (do-sub exps)
    (cond
     ((null? exps) (error "- needs arguments"))
     ((null? (cdr exps)) (do-sub (cons 0 exps)))
     (else (do-binop 'sub exps))))
  (define (do-div exps)
    (cond
     ((null? exps) (error "/ needs arguments"))
     ((null? (cdr exps)) (error "/ needs more arguments"))
     (else (do-binop 'div exps))))

  (cond
   ((integer? exp) (emit 'ldc exp))
   ((symbol? exp)
    (let floop ((env env) (n 0))
      (when (null? env) 
	    (error "unbound variable:" exp))
      (let vloop ((frame (car env)) (i 0))
	(cond
	 ((null? frame) (floop (cdr env) (+ n 1)))
	 ((eq? (car frame) exp) (emit 'ld n i))
	 (else (vloop (cdr frame) (+ i 1)))))))
   ((cons? exp)
    (case (car exp)
      ((+) (do-addmul 'add 0 (cdr exp)))
      ((-) (do-sub (cdr exp)))
      ((*) (do-addmul 'mul 1 (cdr exp)))
      ((/) (do-div (cdr exp)))
      ((= < > <= >= cons)
       (unless (= (length exp) 3)
	 (error "wrong arity for binary operator:" exp))
       (let ((lhs (cadr exp))
	     (rhs (caddr exp)))
	 (case (car exp)
	   ((=) (recur lhs) (recur rhs) (emit 'ceq))
	   ((>) (recur lhs) (recur rhs) (emit 'cgt))
	   ((<) (recur rhs) (recur lhs) (emit 'cgt))
	   ((>=) (recur lhs) (recur rhs) (emit 'cgte))
	   ((<=) (recur rhs) (recur lhs) (emit 'cgte))
	   ((cons) (recur lhs) (recur rhs) (emit 'cons)))))
      ((atom car cdr)
       (unless (= (length exp) 2)
	 (error "wrong arity for unary operator:" exp)
	 (recur (cadr exp))
	 (emit (car exp))))
      ((if)
       (unless (= (length exp) 4)
	 (error "wrong arity for conditional:" exp))
       (let ((>then (emit '_fork))
	     (>else (emit '_fork)))
	 (recur (cadr exp))
	 (emit 'sel (>then '_get) (>else '_get))
	 (cmplr >then env (caddr exp))
	 (>then 'join)
	 (cmplr >else env (cadddr exp))
	 (>else 'join)))
      ((lambda)
       (unless (and (list? (cadr exp)) (andmap symbol? (cadr exp)))
	 (error "unsupported argument list:" exp))
       (unless (= (length exp) 3)
	 (error "no begin (yet):" exp))
       (let ((>body (emit '_fork)))
	 (emit 'ldf (>body '_get))
	 (cmplr >body (cons (cadr exp) env) (caddr exp))
	 (>body 'rtn)))
      ((letrec)
       (unless (and (= (length exp) 3) (andmap (lambda (b) (= (length b) 2)) (cadr exp)))
	 (error "no begin (yet):" exp))
       (let ((vars (map car (cadr exp)))
	     (inits (map cadr (cadr exp)))
	     (body (caddr exp)))
	 (emit 'dum (length vars))
	 (for-each (lambda (init) (cmplr emit (cons vars env) init)) inits)
	 (recur `(lambda ,vars ,body))
	 (emit 'rap (length vars))))

      ;; fake macros
      ((let)
       (unless (and (= (length exp) 3) (andmap (lambda (b) (= (length b) 2)) (cadr exp)))
	 (error "no begin (yet):" exp))
       (let ((vars (map car (cadr exp)))
	     (inits (map cadr (cadr exp)))
	     (body (caddr exp)))
	 (recur `((lambda ,vars ,body) ,@inits))))
      ((let*)
       (if (null? (cadr exp)) (recur (caddr exp))
	   (recur `(let (,(caadr exp)) (let* ,(cdadr exp) ,@(cddr exp))))))

      ;; It must be a function.
      (else
       ;; Yes, this means all the primitive names are PL/I-style semi-reserved words.
       (for-each recur (cdr exp))
       (recur (car exp))
       (emit 'ap (length (cdr exp))))))
   (else (error "unhandled expression:" exp))))

(define (insn-fmt op args)
  (apply string-append (string-upcase (symbol->string op))
	 (map (lambda (arg) (format " ~a" arg)) args)))

(define (simple-emit (pfx 'main))
  (lambda (op . args)
    (case op
     ((_fork) (simple-emit (gensym)))
     ((_get) pfx)
     (else (printf "~a << ~a~n" pfx (insn-fmt op args))))))
